### BJ20058 ë§ˆë²•ì‚¬ ìƒì–´ì™€ íŒŒì´ì–´ìŠ¤í†°

[ğŸ“ë¬¸ì œë³´ê¸°](https://www.acmicpc.net/problem/20058)

---

#### ë¬¸ì œí’€ì´

- í•¨ìˆ˜ ë‚˜ëˆ ì„œ í•¨
- íšŒì „í•˜ê¸°(rotation)
  - `temp[i + a][j + b] = map[i + L - 1 - b][j + a];`
- ì–¼ìŒ ë…¹ì´ê¸°(melt)
  - í•œêº¼ë²ˆì— ë…¹ì—¬ì•¼ í•˜ê¸° ë•Œë¬¸ì— ì¡°ê±´ì— ë§ëŠ” ê²½ìš° listì— ë‹´ê³  ëª¨ë“  íƒìƒ‰ì´ ëë‚˜ë©´ listì— ë‹´ê²¨ì§„ ë§µ ìœ„ì¹˜ì— ì–¼ìŒì„ ë…¹ì¸ë‹¤.


- ë‚¨ì•„ìˆëŠ” ì–¼ìŒ ì¤‘ ê°€ì¥ í° ë©ì–´ë¦¬ê°€ ì°¨ì§€í•˜ëŠ” ì¹¸ì˜ ê°œìˆ˜ëŠ” bfsë¡œ êµ¬í•œë‹¤. bfs íƒìƒ‰í•˜ë©´ì„œ ë‚¨ì•„ìˆëŠ” ì–¼ìŒ í•©ë„ êµ¬í•œë‹¤.

---

#### ì „ì²´ ì½”ë“œ

```java
import java.io.*;
import java.util.*;

public class Main {
  static int[] dx = { 0, 1, 0, -1 }; // â† â†“ â†’ â†‘
  static int[] dy = { -1, 0, 1, 0 };
  static int N, Q, L[], map[][], iceberg, total;

  public static void main(String[] args) throws Exception {
    // System.setIn(new FileInputStream("input.txt"));
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

    // ì…ë ¥
    StringTokenizer st = new StringTokenizer(br.readLine(), " ");
    N = (int) Math.pow(2, Integer.parseInt(st.nextToken())); // 2^N ë§µí¬ê¸°
    Q = Integer.parseInt(st.nextToken()); // ë§ˆë²• ì‹œì „ íšŸìˆ˜
    L = new int[Q]; // ë§ˆë²•ì‚¬ ìƒì–´ê°€ ì‹œì „í•œ ë‹¨ê³„
    map = new int[N][N];

    for (int i = 0; i < N; i++) {
      st = new StringTokenizer(br.readLine(), " ");
      for (int j = 0; j < N; j++) {
        map[i][j] = Integer.parseInt(st.nextToken());
      }
    }
    st = new StringTokenizer(br.readLine());
    for (int i = 0; i < Q; i++) {
      L[i] = Integer.parseInt(st.nextToken());
    }

    // ì²˜ë¦¬
    for (int i = 0; i < Q; i++) {
      map = rotation(L[i]); // íšŒì „í•˜ê¸°
      melt(); // ì–¼ìŒ ë…¹ì´ê¸°
    }
    bfs();

    System.out.println(total);
    System.out.println(iceberg);
  }

  private static int[][] rotation(int L) {
    int[][] temp = new int[N][N];
    L = (int) Math.pow(2, L);
    // Lí¬ê¸°ë§Œí¼ ë¶„ë¦¬
    for (int i = 0; i < N; i += L) {
      for (int j = 0; j < N; j += L) {
        // ì‚¬ê°í˜• ë‚´ íšŒì „
        for (int a = 0; a < L; a++) {
          for (int b = 0; b < L; b++) {
            temp[i + a][j + b] = map[i + L - 1 - b][j + a];
          }
        }
      }
    }
    return temp;
  }

  private static void melt() {
    LinkedList<int[]> temp = new LinkedList<>();
    for (int i = 0; i < N; i++) {
      for (int j = 0; j < N; j++) {
        int cnt = 0;
        if (map[i][j] == 0)
          continue;
        for (int d = 0; d < 4; d++) {
          int nx = i + dx[d];
          int ny = j + dy[d];
          if (nx >= 0 && nx < N && ny >= 0 && ny < N && map[nx][ny] > 0) {
            cnt++;
          }
        }
        if (cnt < 3)
          temp.add(new int[] { i, j });
      }
    }

    while (!temp.isEmpty()) {
      int[] t = temp.poll();
      int x = t[0], y = t[1];
      map[x][y] -= 1;
    }
  }

  private static void bfs() {
    Queue<int[]> q = new LinkedList<>();
    boolean[][] visit = new boolean[N][N];

    for (int i = 0; i < N; i++) {
      for (int j = 0; j < N; j++) {
        total += map[i][j];
        if (map[i][j] == 0 || visit[i][j]) continue;
        q.add(new int[] { i, j });
        visit[i][j] = true;
        int cnt = 1;

        while (!q.isEmpty()) {
          int[] t = q.poll();
          for (int d = 0; d < 4; d++) {
            int nx = t[0] + dx[d];
            int ny = t[1] + dy[d];
            if (nx >= 0 && nx < N && ny >= 0 && ny < N && map[nx][ny] > 0) {
              if (map[nx][ny] > 0 && !visit[nx][ny]) {
                visit[nx][ny] = true;
                q.add(new int[] { nx, ny });
                cnt++;
              }
            }
          }
          iceberg = Math.max(iceberg, cnt);
        }

      }
    }
  }
}
```
