## [ğŸ´â€â˜ ï¸](https://www.acmicpc.net/problem/2589) [bj2589] ë³´ë¬¼ì„¬

> **ì†Œìš” ì‹œê°„: 17ë¶„<br>
> ë©”ëª¨ë¦¬: 51232KB<br>
> ì‹œê°„: 196ms**

## ë¬¸ì œ ì ‘ê·¼

- ìƒí•˜ë‚˜ ì¢Œìš°ì— ì´ì›ƒí•˜ëŠ” ì„¬ì´ ìˆëŠ” ì„¬ì€ ìµœë‹¨ ê±°ë¦¬ë¡œ ì´ë™í•˜ëŠ”ë° ìˆì–´ ê°€ì¥ ê¸´ ì‹œê°„ì´ ê±¸ë¦´ ìˆ˜ ì—†ë‹¤.

## ë¬¸ì œ í’€ì´

1. mapì„ ìˆœì°¨ì ìœ¼ë¡œ í™•ì¸í•˜ë©´ì„œ ì„¬ì¸ê²½ìš°, ìƒí•˜ë‚˜ ì¢Œìš°ì— ì´ì›ƒí•˜ëŠ” ì„¬ì´ ìˆëŠ”ì§€ í™•ì¸í•œë‹¤.<br>
   1-1. ë‘˜ ì¤‘ ì´ì›ƒí•œ ì„¬ì´ ìˆëŠ” ê²½ìš° bfsë¥¼ í˜¸ì¶œí•˜ì§€ ì•Šê³  ë„˜ì–´ê°„ë‹¤.<br>
   1-2. ì•„ë‹Œ ê²½ìš° bfsë¥¼ í˜¸ì¶œí•œë‹¤.<br>

2. bfsë¥¼ í†µí•´ ì´ì›ƒì„¬ë“¤ì„ ìµœë‹¨ê±°ë¦¬ë¡œ ì´ë™í•˜ë©° ì‹œê°„ì„ ì²´í¬í•œë‹¤.

3. íì—ì„œ ë§ˆì§€ë§‰ìœ¼ë¡œ ì €ì¥ëœ ì„¬ì˜ ì‹œê°„ì´ MAXë³´ë‹¤ í° ê²½ìš° MAXê°’ì„ ê°±ì‹ í•œë‹¤.

4. MAXë¥¼ ì¶œë ¥í•œë‹¤.

## ì „ì²´ ì½”ë“œ

```java
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.LinkedList;
import java.util.Queue;
import java.util.StringTokenizer;

public class Main_bj2589 {
    static final int[] di = {-1, 0, 1, 0};
    static final int[] dj = {0, 1, 0, -1};
    static Queue<int[]> queue;
    static int R, C;
    static char[][] map;
    static int MAX;

    public static void main(String args[]) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine(), " ");
        R = Integer.parseInt(st.nextToken());
        C = Integer.parseInt(st.nextToken());
        map = new char[R][];
        for (int r = 0; r < R; r++) {
            map[r] = br.readLine().toCharArray();
        }

        queue = new LinkedList<>();
        MAX = 0;
        for (int r = 0; r < R; r++) {
            next:
            for (int c = 0; c < C; c++) {
                if (map[r][c] == 'L') {
                    for (int z = 0; z < 2; z++) {
                        int ai = r + di[z];
                        int aj = c + dj[z];
                        int bi = r + di[z + 2];
                        int bj = c + dj[z + 2];
                        if (valid(ai, aj) && valid(bi, bj)) continue next;
                    }
                    bfs(r, c);
                }
            }
        }

        System.out.println(MAX);
    }

    static void bfs(int r, int c) {
        boolean[][] visited = new boolean[R][C];

        queue.offer(new int[]{r, c, 0});
        visited[r][c] = true;

        while (true) {
            int[] node = queue.poll();
            int i = node[0];
            int j = node[1];
            int t = node[2];

            for (int z = 0; z < 4; z++) {
                int ni = i + di[z];
                int nj = j + dj[z];
                if (valid(ni, nj) && !visited[ni][nj]) {
                    visited[ni][nj] = true;
                    queue.offer(new int[]{ni, nj, t + 1});
                }
            }

            if (queue.isEmpty()) {
                if (MAX < t) MAX = t;
                break;
            }
        }
    }

    static boolean valid(int i, int j) {
        return i >= 0 && i < R && j >= 0 && j < C && map[i][j] == 'L';
    }

}
```
