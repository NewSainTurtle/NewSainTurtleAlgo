## ğŸ”¢ [bj17140] ì´ì°¨ì› ë°°ì—´ê³¼ ì—°ì‚°

- [ë°”ë¡œê°€ê¸°](https://www.acmicpc.net/problem/17140)

- ì†Œìš” ì‹œê°„: 34 ë¶„
- ë©”ëª¨ë¦¬: 14144 KB
- ì‹œê°„: 112 ms

## ë¬¸ì œ ì ‘ê·¼

- ì¹´ìš´íŠ¸ëŠ” 100ì„ ë„˜ì§€ ì•ŠëŠ”ë‹¤
- ì¹´ìš´íŠ¸ í›„ ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ ì •ë ¬ì„ í•´ì•¼í•œë‹¤
- ì¹´ìš´íŠ¸ê°€ ê°™ì€ ê²½ìš° ìˆ«ìë¥¼ ê¸°ì¤€ìœ¼ë¡œ ì˜¤ë¦„ì°¨ìˆœì´ ë˜ì–´ì•¼ í•œë‹¤
- ì¹´ìš´íŠ¸í•˜ë©´ì„œ í•´ë‹¹ë¶€ë¶„ì€ 0ìœ¼ë¡œ ì´ˆê¸°í™”

## ë¬¸ì œ í’€ì´

1. r,c,kë¥¼ ì…ë ¥ë°›ëŠ”ë‹¤ (r,cëŠ” í¸ì˜ìƒ -1í•¨)

2. 100\*100 2ì°¨ì› ë°°ì—´ mapì„ ì •ì˜í•˜ê³  ì…ë ¥ë°›ëŠ”ë‹¤

3. ìµœëŒ€ í–‰,ì—´ í¬ê¸°ë¥¼ êµ¬í•˜ê¸° ìœ„í•´ maxR, maxCë¥¼ ì„ ì–¸í•˜ê³  3ìœ¼ë¡œ ì´ˆê¸°í™”í•œë‹¤. ì‹œê°„ì„ ì²´í¬í•˜ê¸° ìœ„í•´ timeì„ ì„ ì–¸í•˜ê³  0ìœ¼ë¡œ ì´ˆê¸°í™”í•œë‹¤

4. ìˆ«ìë¥¼ ì¹´ìš´íŠ¸í•  1ì°¨ì› ë°°ì—´ tmpë¥¼ 101í¬ê¸°ë¡œ ì •ì˜í•œë‹¤ (tmp[100]ì„ ì‚¬ìš©í•˜ê¸° ìœ„í•´)

5. map[r][c]ê°€ kê°€ ë˜ê±°ë‚˜, timeì´ 100ì„ ë„˜ê¸°ê¸° ì „ê¹Œì§€ ë°˜ë³µë¬¸ì„ ê³„ì†í•œë‹¤(6-7)

6. maxRì´ maxCë³´ë‹¤ í¬ê±°ë‚˜ ê°™ì€ ê²½ìš° Rì—°ì‚°ì„ í•œë‹¤<br>
   6-1. Rì—°ì‚°ì„ ìˆ˜í–‰í•˜ê¸° ìœ„í•´ í–‰ì„ ìˆœì°¨ì ìœ¼ë¡œ ì ‘ê·¼í•œë‹¤. ì—´ì„ ìˆœì°¨ì ìœ¼ë¡œ ì ‘ê·¼í•˜ë©´ì„œ ìˆ«ìë¥¼ ì¹´ìš´íŠ¸í•œë‹¤. map[i][j]ê°€ 0ë³´ë‹¤ í°ê²½ìš° map[i][j] ìˆ«ìë¥¼ ì¹´ìš´íŠ¸í•˜ê¸° ìœ„í•´ tmp[map[i][j]]ì„ 1ì¦ê°€ ì‹œí‚¤ê³ , map[i][j]ì€ 0ìœ¼ë¡œ ì´ˆê¸°í™”í•œë‹¤<br>
   6-2. Nodeë¥¼ ì›ì†Œë¡œ í•˜ëŠ” ìš°ì„ ìˆœìœ„ íë¥¼ ìƒì„±í•œë‹¤<br>
   6-3. 1ë¶€í„° 100ê¹Œì§€ tmpì— ì¹´ìš´íŠ¸ëœ ìˆ«ìê°€ ìˆëŠ” ê²½ìš° Node ê°ì²´ë¥¼ ìƒì„±í•´ ìš°ì„ ìˆœìœ„ íì— ë„£ê³ , ì´ˆê¸°í™”í•œë‹¤<br>
   6-4. ìš°ì„ ìˆœìœ„ íê°€ ë¹„ê±°ë‚˜, ì¸ë±ìŠ¤ê°€ 100ì„ ë„˜ê¸°ê¸°ì „ê¹Œì§€ ë°˜ë³µí•˜ì—¬ mapì— ìˆ«ìì™€ ì¹´ìš´íŠ¸ê°’ì„ ë„£ëŠ”ë‹¤<br>
   6-5. maxCë³´ë‹¤ ì¸ë±ìŠ¤ê°€ í¬ë‹¤ë©´ maxCê°’ì„ ê°±ì‹ í•œë‹¤<br>

7. maxRì´ maxCë³´ë‹¤ ì‘ì€ ê²½ìš° Cì—°ì‚°ì„ í•œë‹¤

8. timeì´ 100ë³´ë‹¤ í¬ë©´ -1ì„, ì•„ë‹ˆë¼ë©´ timeì„ ì¶œë ¥í•œë‹¤

## ì „ì²´ ì½”ë“œ

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.PriorityQueue;
import java.util.StringTokenizer;

public class Main_bj17140 {

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine(), " ");
        int r = Integer.parseInt(st.nextToken()) - 1, c = Integer.parseInt(st.nextToken()) - 1, k = Integer.parseInt(st.nextToken());
        int[][] map = new int[100][100];
        int maxR = 3, maxC = 3, time = 0;

        for (int i = 0; i < 3; i++) {
            st = new StringTokenizer(br.readLine(), " ");
            for (int j = 0; j < 3; j++) {
                map[i][j] = Integer.parseInt(st.nextToken());
            }
        }

        int[] tmp = new int[101];
        while (map[r][c] != k && time++ < 100) {
            if (maxR >= maxC) {
                for (int i = 0; i < maxR; i++) {
                    for (int j = 0; j < maxC; j++) {
                        if (map[i][j] > 0) {
                            tmp[map[i][j]]++;
                            map[i][j] = 0;
                        }
                    }
                    PriorityQueue<Node> pq = new PriorityQueue();
                    for (int idx = 1; idx <= 100; idx++) {
                        if (0 < tmp[idx]) {
                            pq.offer(new Node(idx, tmp[idx]));
                            tmp[idx] = 0;
                        }
                    }

                    int tmpC = 0;
                    while (!pq.isEmpty() && tmpC < 100) {
                        Node node = pq.poll();
                        map[i][tmpC++] = node.num;
                        map[i][tmpC++] = node.cnt;
                    }
                    if (maxC < tmpC) maxC = tmpC;
                }
            } else {
                for (int j = 0; j < maxC; j++) {
                    for (int i = 0; i < maxR; i++) {
                        if (map[i][j] > 0) {
                            tmp[map[i][j]]++;
                            map[i][j] = 0;
                        }
                    }
                    PriorityQueue<Node> pq = new PriorityQueue();
                    for (int idx = 1; idx <= 100; idx++) {
                        if (0 < tmp[idx]) {
                            pq.offer(new Node(idx, tmp[idx]));
                            tmp[idx] = 0;
                        }
                    }
                    int tmpR = 0;
                    while (!pq.isEmpty() && tmpR < 100) {
                        Node node = pq.poll();
                        map[tmpR++][j] = node.num;
                        map[tmpR++][j] = node.cnt;
                    }
                    if (maxR < tmpR) maxR = tmpR;
                }
            }
        }

        System.out.print(time > 100 ? -1 : time);
        br.close();
    }

    static class Node implements Comparable<Node> {

        int num;
        int cnt;

        public Node(int num, int cnt) {
            this.num = num;
            this.cnt = cnt;
        }

        @Override
        public int compareTo(Node o) {
            return this.cnt == o.cnt ? this.num - o.num : this.cnt - o.cnt;
        }
    }
}
```
