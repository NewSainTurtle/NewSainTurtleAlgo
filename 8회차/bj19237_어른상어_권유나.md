## [ğŸ¦ˆ](https://www.acmicpc.net/problem/19237) [bj19237] ì–´ë¥¸ ìƒì–´

> **ì†Œìš” ì‹œê°„: 159ë¶„<br>
> ë©”ëª¨ë¦¬: 29676KB<br>
> ì‹œê°„: 304ms**

## ë¬¸ì œ ì ‘ê·¼

- ìƒì–´ì˜ ëƒ„ìƒˆë¥¼ í•´ì‰¬ë§µì„ ì´ìš©í•´ í‘œí˜„í•œë‹¤.

## ë¬¸ì œ í’€ì´

1. sharks: ìƒì–´ì˜ ë²ˆí˜¸ëŒ€ë¡œ ìœ„ì¹˜+ë°©í–¥ ì €ì¥<br>
   direction: ìƒì–´ì˜ ë²ˆí˜¸ëŒ€ë¡œ ë°©í–¥ ìš°ì„ ìˆœìœ„ ì €ì¥ (â†‘: 0~3,â†“:4~7 ,â†:8~11 ,â†’:12~15 )<br>
   smells: ìƒì–´ì˜ ëƒ„ìƒˆë¥¼ ì €ì¥ (key: ìƒì–´ë²ˆí˜¸, value: ì‹œê°„)<br>
   queue: ìƒì–´ì˜ ëƒ„ìƒˆë¥¼ ì—†ì• ê¸° ìœ„í•œ í<br>

2. timeì´ 1000ì´í•˜ì¸ ê²½ìš° ë°˜ë³µí•œë‹¤.

3. ìƒì–´ë¥¼ ìˆœì°¨ì ìœ¼ë¡œ ì ‘ê·¼í•œë‹¤. ìƒì–´ê°€ ì£½ì€ê²½ìš° ë‹¤ìŒ ìƒì–´ë¡œ ë„˜ì–´ê°„ë‹¤. (3~5)

4. ìƒì–´ì˜ ìš°ì„ ìˆœìœ„ëŒ€ë¡œ 4ë°©í–¥ì„ í™•ì¸í•œë‹¤. ìœ íš¨ë²”ìœ„ë‚´ì— ìˆì„ ë•Œ,<br>
   4-1. í•´ë‹¹ ìœ„ì¹˜ì˜ smellsë¥¼ ëª¨ë‘ í™•ì¸í•˜ë©° ì‹œê°„ì´ ì§€ë‚œ ëƒ„ìƒˆë“¤ì€ ì œê±°í•œë‹¤.<br>
   4-2. smellsì˜ í¬ê¸°ê°€ 0ì¼ ë•Œ í•´ë‹¹ ìœ„ì¹˜ë¡œ ìƒì–´ë¥¼ ì´ë™ì‹œí‚¨ í›„ ë°˜ë³µë¬¸(3ë²ˆ)ì„ ì¢…ë£Œí•œë‹¤.<br>
        ì´ë•Œ ì´ë™ì‹œí‚¨ ìœ„ì¹˜ì— ë‹¤ë¥¸ ìƒì–´ê°€ ìˆëŠ” ê²½ìš°ëŠ” ìƒì–´ê°€ ì£½ê³  cntë¥¼ 1 ê°ì†Œ ì‹œí‚¨ë‹¤.<br>
   4-3. ì•„ë‹Œ ê²½ìš° ìš°ì„  smellsì— í•´ë‹¹ ìƒì–´ëƒ„ìƒˆê°€ ìˆëŠ”ì§€ í™•ì¸í•œë‹¤.<br>
   4-4. ëƒ„ìƒˆê°€ ìˆê³ , tmp_d_meì— ì• ë°©í–¥ë“¤ì´ ì €ì¥ë˜ì§€ ì•Šì•˜ë‹¤ë©´, tmp_d_meì— ë°©í–¥ì„ ì €ì¥í•œë‹¤.(ë‚˜ì¤‘ì— ëª¨ë“  ë°©í–¥ì— ëƒ„ìƒˆê°€ ìˆëŠ” ê²½ìš° ì´ ë°©í–¥ìœ¼ë¡œ ìƒì–´ê°€ ì´ë™í•œë‹¤.)<br>
   4-5. ëƒ„ìƒˆê°€ ì—†ê³ , tmp_d_not_meì— ì• ë°©í–¥ë“¤ì´ ì €ì¥ë˜ì§€ ì•Šì•˜ë‹¤ë©´, tmp_d_not_meì— ë°©í–¥ì„ ì €ì¥í•œë‹¤.(ë‚˜ì¤‘ì— ëª¨ë“  ë°©í–¥ì— ëƒ„ìƒˆê°€ ìˆê³ , ë‚´ ëƒ„ìƒˆê°€ ì €ì¥ëœ ê³³ì´ ì—†ëŠ” ê²½ìš° ì´ ë°©í–¥ìœ¼ë¡œ ìƒì–´ê°€ ì´ë™í•œë‹¤.)<br>

5. ë‚˜ì¤‘ì— ëª¨ë“  ë°©í–¥ì— ëƒ„ìƒˆê°€ ìˆëŠ” ê²½ìš°, <br>
   tmp_d_meì— ë±¡í–¥ì— ì €ì¥ë˜ì–´ ìˆë‹¤ë©´ dirì— tmp_d_meë¥¼ ì €ì¥í•˜ê³ , ì•„ë‹ˆë¼ë©´ tmp_d_not_meë¥¼ ì €ì¥í•´ ìƒì–´ë¥¼ ì´ë™ì‹œí‚¨ë‹¤.<br>
   ì´ë•Œ ì´ë™ì‹œí‚¨ ìœ„ì¹˜ì— ë‹¤ë¥¸ ìƒì–´ê°€ ìˆëŠ” ê²½ìš°ëŠ” ìƒì–´ê°€ ì£½ê³  cntë¥¼ 1 ê°ì†Œ ì‹œí‚¨ë‹¤.

6. ìƒì–´ ì´ë™ì´ ëª¨ë‘ ëë‚˜ë©´, ë‹¤ì‹œ ìƒì–´ë¥¼ ìˆœì°¨ì ìœ¼ë¡œ ì ‘ê·¼í•´ ìƒì–´ ëƒ„ìƒˆë¥¼ ë‚¨ê¸°ê³ , mapì„ ì´ˆê¸°í™” ì‹œí‚¨ë‹¤.

7. cntê°€ 1ì´ë¼ë©´ timeì„ ë°˜í™˜í•˜ê³ , ì•„ë‹ˆë¼ë©´ 2ë²ˆì„ ë°˜ë³µí•œë‹¤.

8. timeì´ 1000ë³´ë‹¤ í° ê²½ìš° -1ì„ ë°˜í™˜í•œë‹¤.

9. playì˜ ë°˜í™˜ê°’ì„ ì¶œë ¥í•œë‹¤.

## ì „ì²´ ì½”ë“œ

```java
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.*;

public class Main_bj19237 {

    static int N, M, K;
    static int[][] sharks, direction;
    static Map<Integer, Integer>[][] smells;
    static boolean[][] map;

    public static void main(String args[]) throws Exception {
        init();
        System.out.println(play());
    }

    static void init() throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine(), " ");

        N = Integer.parseInt(st.nextToken());
        M = Integer.parseInt(st.nextToken());
        K = Integer.parseInt(st.nextToken());

        //ìƒì–´ ìœ„ì¹˜ ì €ì¥
        sharks = new int[M + 1][];
        direction = new int[M + 1][4 * 4];
        smells = new HashMap[N][N];

        for (int i = 0; i < N; i++) {
            st = new StringTokenizer(br.readLine(), " ");
            for (int j = 0; j < N; j++) {
                int tmp = Integer.parseInt(st.nextToken());
                smells[i][j] = new HashMap<>();
                if (tmp != 0) {
                    sharks[tmp] = new int[]{i, j, 0};
                    smells[i][j].put(tmp, 0);
                }
            }
        }

        //ìƒì–´ ì •ë³´
        st = new StringTokenizer(br.readLine(), " ");
        for (int s = 1; s <= M; s++) {
            sharks[s][2] = Integer.parseInt(st.nextToken()) - 1;
        }

        for (int s = 1; s <= M; s++) {
            int idx = 0;
            for (int j = 0; j < 4; j++) {
                st = new StringTokenizer(br.readLine(), " ");
                for (int z = 0; z < 4; z++) {
                    direction[s][idx++] = Integer.parseInt(st.nextToken()) - 1;
                }
            }
        }
    }

    static int play() {
        final int[] di = {-1, 1, 0, 0};
        final int[] dj = {0, 0, -1, 1};

        int time = 0;
        int cnt = M;
        Queue<Integer> queue = new LinkedList<>();
        map = new boolean[N][N];

        while (time++ < 1000) {
            for (int s = 1; s <= M; s++) {
                if (sharks[s] == null) continue;
                int i = sharks[s][0];
                int j = sharks[s][1];
                int d = sharks[s][2];

                //ì´ë™
                int tmp_d_me = -1;
                int tmp_d_not_me = -1;

                for (int z = 0; z < 4; z++) {
                    int dir = direction[s][d * 4 + z];
                    int ni = i + di[dir];
                    int nj = j + dj[dir];

                    if (ni >= 0 && ni < N && nj >= 0 && nj < N) {
                        for (Integer key : smells[ni][nj].keySet()) {
                            if (time - smells[ni][nj].get(key) > K) {
                                queue.offer(key);
                            }
                        }
                        while (!queue.isEmpty()) {
                            smells[ni][nj].remove(queue.poll());
                        }

                        if (smells[ni][nj].size() == 0) {
                            cnt += move(ni, nj, dir, s);
                            break;
                        }

                        if (smells[ni][nj].containsKey(s)) {
                            if (tmp_d_me == -1) tmp_d_me = dir;
                        } else if (tmp_d_not_me == -1) {
                            tmp_d_not_me = dir;
                        }
                    }
                }

                if (sharks[s] != null && sharks[s][0] == i && sharks[s][1] == j) {
                    int dir = tmp_d_me == -1 ? tmp_d_not_me : tmp_d_me;
                    int ni = i + di[dir];
                    int nj = j + dj[dir];
                    cnt += move(ni, nj, dir, s);
                }
            }

            for (int s = 1; s <= M; s++) {
                //ëƒ„ìƒˆ ë¿Œë¦¬ê¸°
                if (sharks[s] != null) {
                    smells[sharks[s][0]][sharks[s][1]].put(s, time);
                    map[sharks[s][0]][sharks[s][1]] = false;
                }
            }

            if (cnt == 1) return time;
        }
        return -1;
    }

    static int move(int i, int j, int dir, int s) {
        if (map[i][j]) {
            sharks[s] = null;
            return -1;
        } else {
            sharks[s][0] = i;
            sharks[s][1] = j;
            sharks[s][2] = dir;
            map[i][j] = true;
            return 0;
        }
    }
}
```
