## [ğŸ„](https://www.acmicpc.net/problem/1197) [bj1197] ìµœì†Œ ìŠ¤íŒ¨ë‹ íŠ¸ë¦¬

> **ì†Œìš” ì‹œê°„: 62ë¶„<br>
> ë©”ëª¨ë¦¬: 60864KB<br>
> ì‹œê°„: 816ms**

## ë¬¸ì œ ì ‘ê·¼

- í”„ë¦¼ì„ ì´ìš©í•´ ë¬¸ì œë¥¼ í’€ì—ˆë‹¤. 
- í¬ë£¨ìŠ¤ì¹¼ì´ë‚˜ ë‹¤ìµìŠ¤íŠ¸ë¼ë¡œë„ í’€ ìˆ˜ ìˆëŠ”ê±° ê°™ë‹¤.

## ë¬¸ì œ í’€ì´

1. ê° ì •ì ë§ˆë‹¤ ê°„ì„ ìœ¼ë¡œ ì´ì–´ì ¸ìˆëŠ” ì •ì ê³¼ ê°€ì¤‘ì¹˜ ê°’ì„ `edges`ì— ì €ì¥í•œë‹¤. `visited`ëŠ” ê·¸ë˜í”„ì— í¬í•¨ëœ ì •ì ì„ í‘œì‹œí•œë‹¤.

2. ë¹„êµí•˜ëŠ” ê°„ì„ ë“¤ ì¤‘ ê°€ì¤‘ì¹˜ê°’ì´ ê°€ì¥ ì‘ì€ ê²ƒì„ ìš°ì„ ìœ¼ë¡œ í•˜ëŠ” ìš°ì„ ìˆœìœ„í `pq`ë¥¼ ì„ ì–¸í•œë‹¤.

3. 1ë²ˆ ì •ì ì€ ì´ë¯¸ í¬í•¨ë˜ì–´ìˆë‹¤ê³  ê°€ì •í•˜ê³ , ì…ë ¥ì„ ë°›ìœ¼ë©´ì„œ Aë‚˜ Bê°€ 1ì¸ ê²½ìš° í•´ë‹¹ ì…ë ¥ì„ `pq`ì— ë„£ëŠ”ë‹¤. ì•„ë‹ˆë¼ë©´, `edges`ì˜ ê° ì •ì ì— ë„£ëŠ”ë‹¤.

4. pqì˜ ê°’ì´ ì—†ì„ë•Œë™ì•ˆ ë°˜ë³µí•œë‹¤.<br>
   4-1. pqì—ì„œ ì›ì†Œë¥¼ ë¹¼ì„œ `node`ì— ì €ì¥í•œë‹¤.<br>
   4-2. ì •ì (node[0])ì´ ì´ë¯¸ ê·¸ë˜í”„ì— í¬í•¨ëœ ê²½ìš° ë‹¤ìŒ ë°˜ë³µë¬¸ìœ¼ë¡œ ë„˜ì–´ê°„ë‹¤.<br>
   4-3. ì •ì ì´ ê·¸ë˜í”„ì— í¬í•¨ë˜ì§€ ì•Šì€ ê²½ìš°, ê°€ì¤‘ì¹˜ê°’ì„ `cost`ì— ë”í•˜ê³  ì •ì ì„ ê·¸ë˜í”„ì— í¬í•¨ì‹œí‚¨ë‹¤.<br>
   4-4. ëª¨ë“  ì •ì ì´ ê·¸ë˜í”„ì— í¬í•¨ë˜ì–´ MSTê°€ ì™„ì„±ë˜ì—ˆë‹¤ë©´ ë°˜ë³µë¬¸ì„ ì¢…ë£Œí•œë‹¤.<br>
   4-5. ì•„ë‹ˆë¼ë©´, í•´ë‹¹ ì •ì ê³¼ ì—°ê²°ëœ ê°„ì„  ì •ë³´ë¥¼ pqì— ë„£ëŠ”ë‹¤.<br>

5. `cost`ë¥¼ ì¶œë ¥í•œë‹¤.

## ì „ì²´ ì½”ë“œ

```java
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.List;
import java.util.PriorityQueue;
import java.util.StringTokenizer;

public class Main_1197_ìµœì†ŒìŠ¤íŒ¨ë‹íŠ¸ë¦¬ {

    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine(), " ");
        int V = Integer.parseInt(st.nextToken());
        int E = Integer.parseInt(st.nextToken());

        List<int[]>[] edges = new ArrayList[V + 1];
        boolean[] visited = new boolean[V + 1];

        int cnt = 0;
        int cost = 0;

        PriorityQueue<int[]> pq = new PriorityQueue<>((o1, o2) -> Integer.compare(o1[1], o2[1]));
        visited[1] = true;
        for (int v = 1; v <= V; v++) {
            edges[v] = new ArrayList<>();
        }

        for (int e = 0; e < E; e++) {
            st = new StringTokenizer(br.readLine(), " ");
            int A = Integer.parseInt(st.nextToken());
            int B = Integer.parseInt(st.nextToken());
            int C = Integer.parseInt(st.nextToken());
            if (A == 1) {
                pq.offer(new int[]{B, C});
            } else if (B == 1) {
                pq.offer(new int[]{A, C});
            } else {
                edges[A].add(new int[]{B, C});
                edges[B].add(new int[]{A, C});
            }
        }

        while (!pq.isEmpty()) {
            int[] node = pq.poll();
            if (visited[node[0]]) continue;

            cost += node[1];
            if (++cnt == V - 1) break;
            visited[node[0]] = true;

            for (int[] edge : edges[node[0]]) {
                pq.offer(edge);
            }
        }

        System.out.println(cost);
    }
}
```
